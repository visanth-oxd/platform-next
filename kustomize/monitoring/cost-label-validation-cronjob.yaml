---
# Cost Label Validation CronJob
# Runs daily to validate cost labels on all Kubernetes resources
# Exports metrics to Prometheus Pushgateway

apiVersion: v1
kind: ServiceAccount
metadata:
  name: cost-label-validator
  namespace: monitoring

---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: cost-label-validator
rules:
  # Read pods
  - apiGroups: [""]
    resources: ["pods"]
    verbs: ["list", "get"]
  
  # Read deployments
  - apiGroups: ["apps"]
    resources: ["deployments", "statefulsets", "daemonsets"]
    verbs: ["list", "get"]
  
  # Read services
  - apiGroups: [""]
    resources: ["services"]
    verbs: ["list", "get"]

---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: cost-label-validator
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: cost-label-validator
subjects:
  - kind: ServiceAccount
    name: cost-label-validator
    namespace: monitoring

---
apiVersion: batch/v1
kind: CronJob
metadata:
  name: cost-label-validation
  namespace: monitoring
  labels:
    app: cost-label-validation
    component: monitoring
    platform: platform-next

spec:
  # Run daily at 2 AM UTC (after GCP billing export, before business hours)
  schedule: "0 2 * * *"
  
  # Keep last 3 successful and 1 failed job for debugging
  successfulJobsHistoryLimit: 3
  failedJobsHistoryLimit: 1
  
  # Skip concurrent runs if one is already in progress
  concurrencyPolicy: Forbid
  
  jobTemplate:
    spec:
      template:
        metadata:
          labels:
            app: cost-label-validation
            component: monitoring
        
        spec:
          serviceAccountName: cost-label-validator
          
          # Run with appropriate permissions
          securityContext:
            runAsNonRoot: true
            runAsUser: 1000
            fsGroup: 1000
          
          containers:
            - name: validator
              image: python:3.11-slim
              imagePullPolicy: IfNotPresent
              
              # Set working directory
              workingDir: /app
              
              # Run the validation script
              command:
                - /bin/bash
                - -c
                - |
                  set -e
                  echo "Installing dependencies..."
                  pip install -q kubernetes prometheus-client
                  
                  echo "Running cost label validation..."
                  python cost-label-validation.py \
                    --pushgateway http://prometheus-pushgateway.monitoring.svc.cluster.local:9091
                  
                  echo "Validation complete"
              
              # Copy script into container
              volumeMounts:
                - name: script
                  mountPath: /app
              
              # Resource limits
              resources:
                requests:
                  cpu: 100m
                  memory: 256Mi
                limits:
                  cpu: 500m
                  memory: 512Mi
              
              # Security context
              securityContext:
                allowPrivilegeEscalation: false
                readOnlyRootFilesystem: true
                capabilities:
                  drop:
                    - ALL
              
              # Environment
              env:
                - name: PYTHONUNBUFFERED
                  value: "1"
          
          # Mount the validation script
          volumes:
            - name: script
              configMap:
                name: cost-label-validation-script
                defaultMode: 0755
          
          # Restart policy
          restartPolicy: OnFailure
          
          # Timeout for the entire job
          activeDeadlineSeconds: 3600  # 1 hour timeout
          
          # Node affinity to use monitoring nodes if available
          affinity:
            nodeAffinity:
              preferredDuringSchedulingIgnoredDuringExecution:
                - weight: 100
                  preference:
                    matchExpressions:
                      - key: workload-type
                        operator: In
                        values:
                          - monitoring

---
apiVersion: v1
kind: ConfigMap
metadata:
  name: cost-label-validation-script
  namespace: monitoring
  labels:
    app: cost-label-validation
    component: monitoring

data:
  cost-label-validation.py: |
    #!/usr/bin/env python3
    """
    Cost Label Validation Job
    
    Daily job that validates cost labels on all Kubernetes resources.
    Exports metrics about label coverage and correctness.
    """
    
    import os
    import re
    import logging
    from datetime import datetime
    from kubernetes import client, config
    from prometheus_client import CollectorRegistry, Gauge, Counter, push_to_gateway
    
    # Setup logging
    logging.basicConfig(
        level=logging.INFO,
        format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
    )
    logger = logging.getLogger(__name__)
    
    # ========================================
    # METRIC DEFINITIONS
    # ========================================
    
    registry = CollectorRegistry()
    
    pods_missing_cost_label = Gauge(
        'pods_missing_cost_label',
        'Number of pods without required cost labels',
        ['label_type'],
        registry=registry
    )
    
    deployments_missing_cost_label = Gauge(
        'deployments_missing_cost_label',
        'Number of deployments without required cost labels',
        ['label_type'],
        registry=registry
    )
    
    pods_with_valid_labels = Gauge(
        'pods_with_valid_labels',
        'Number of pods with all required cost labels correctly formatted',
        registry=registry
    )
    
    deployments_with_valid_labels = Gauge(
        'deployments_with_valid_labels',
        'Number of deployments with all required cost labels',
        registry=registry
    )
    
    invalid_label_format_total = Counter(
        'invalid_label_format_total',
        'Number of resources with incorrectly formatted cost labels',
        ['label_type', 'reason'],
        registry=registry
    )
    
    cost_label_completeness_ratio = Gauge(
        'cost_label_completeness_ratio',
        'Ratio of resources with complete and valid cost labels',
        ['resource_type'],
        registry=registry
    )
    
    pods_by_environment = Gauge(
        'pods_by_environment',
        'Total number of pods by environment',
        ['environment'],
        registry=registry
    )
    
    cost_label_validation_timestamp = Gauge(
        'cost_label_validation_timestamp',
        'Unix timestamp of last validation run',
        registry=registry
    )
    
    # ========================================
    # VALIDATION FUNCTIONS
    # ========================================
    
    REQUIRED_COST_LABELS = [
        'cost.service',
        'cost.team',
        'cost.environment',
        'cost.costCenter',
        'cost.businessUnit'
    ]
    
    def validate_cost_center_format(value):
        return bool(re.match(r'^CC-\d{5}$', value))
    
    def validate_environment_format(value):
        return value in ['int-stable', 'pre-stable', 'prod']
    
    def validate_label_value(label_key, label_value):
        if not label_value:
            return (False, 'empty_value')
        
        if label_key == 'cost.costCenter':
            if not validate_cost_center_format(label_value):
                return (False, 'invalid_cc_format')
        
        elif label_key == 'cost.environment':
            if not validate_environment_format(label_value):
                return (False, 'invalid_environment')
        
        return (True, '')
    
    def validate_pod_labels(pod):
        labels = pod.metadata.labels or {}
        missing_labels = []
        invalid_labels = []
        
        for required_label in REQUIRED_COST_LABELS:
            if required_label not in labels:
                missing_labels.append(required_label)
            else:
                is_valid, reason = validate_label_value(
                    required_label,
                    labels[required_label]
                )
                if not is_valid:
                    invalid_labels.append((required_label, reason))
        
        for label_key, reason in invalid_labels:
            invalid_label_format_total.labels(
                label_type=label_key,
                reason=reason
            ).inc()
        
        has_all = len(missing_labels) == 0 and len(invalid_labels) == 0
        return (has_all, missing_labels + [f"{k} ({r})" for k, r in invalid_labels])
    
    def validate_deployment_labels(deployment):
        labels = deployment.spec.template.metadata.labels or {}
        missing_labels = []
        
        for required_label in REQUIRED_COST_LABELS:
            if required_label not in labels:
                missing_labels.append(required_label)
        
        return (len(missing_labels) == 0, missing_labels)
    
    # ========================================
    # VALIDATION JOB
    # ========================================
    
    def run_validation():
        logger.info("Starting cost label validation")
        start_time = datetime.now()
        
        try:
            config.load_incluster_config()
        except:
            config.load_kube_config()
        
        v1 = client.CoreV1Api()
        apps_v1 = client.AppsV1Api()
        
        # Validate pods
        logger.info("Validating pods...")
        pods_missing_by_label = {label: 0 for label in REQUIRED_COST_LABELS}
        pods_with_valid = 0
        pods_by_env = {}
        
        all_pods = v1.list_pod_for_all_namespaces()
        total_pods = len(all_pods.items)
        
        for pod in all_pods.items:
            env = pod.metadata.labels.get('cost.environment', 'unknown') if pod.metadata.labels else 'unknown'
            pods_by_env[env] = pods_by_env.get(env, 0) + 1
            
            has_all_labels, missing = validate_pod_labels(pod)
            if has_all_labels:
                pods_with_valid += 1
            else:
                for missing_label in missing:
                    label_key = missing_label.split(' (')[0] if '(' in missing_label else missing_label
                    if label_key in pods_missing_by_label:
                        pods_missing_by_label[label_key] += 1
        
        for label_key, count in pods_missing_by_label.items():
            pods_missing_cost_label.labels(label_type=label_key).set(count)
        
        pods_with_valid_labels.set(pods_with_valid)
        
        for env, count in pods_by_env.items():
            pods_by_environment.labels(environment=env).set(count)
        
        completeness = pods_with_valid / total_pods if total_pods > 0 else 1.0
        cost_label_completeness_ratio.labels(resource_type='pod').set(completeness)
        
        logger.info(f"Pods: {total_pods} total, {pods_with_valid} valid ({completeness*100:.1f}%)")
        
        # Validate deployments
        logger.info("Validating deployments...")
        deployments_missing_by_label = {label: 0 for label in REQUIRED_COST_LABELS}
        deployments_with_valid = 0
        
        all_deployments = apps_v1.list_deployment_for_all_namespaces()
        total_deployments = len(all_deployments.items)
        
        for deployment in all_deployments.items:
            has_all_labels, missing = validate_deployment_labels(deployment)
            if has_all_labels:
                deployments_with_valid += 1
            else:
                for missing_label in missing:
                    if missing_label in deployments_missing_by_label:
                        deployments_missing_by_label[missing_label] += 1
        
        for label_key, count in deployments_missing_by_label.items():
            deployments_missing_cost_label.labels(label_type=label_key).set(count)
        
        deployments_with_valid_labels.set(deployments_with_valid)
        
        completeness = deployments_with_valid / total_deployments if total_deployments > 0 else 1.0
        cost_label_completeness_ratio.labels(resource_type='deployment').set(completeness)
        
        logger.info(f"Deployments: {total_deployments} total, {deployments_with_valid} valid ({completeness*100:.1f}%)")
        
        cost_label_validation_timestamp.set(datetime.now().timestamp())
        
        end_time = datetime.now()
        duration = (end_time - start_time).total_seconds()
        logger.info(f"Validation completed in {duration:.1f}s")
        
        return True
    
    # ========================================
    # MAIN
    # ========================================
    
    if __name__ == '__main__':
        import argparse
        
        parser = argparse.ArgumentParser(description='Cost Label Validation Job')
        parser.add_argument('--pushgateway', default='http://prometheus-pushgateway:9091',
                            help='Prometheus Pushgateway URL')
        args = parser.parse_args()
        
        if run_validation():
            push_to_gateway(args.pushgateway, job='cost-label-validation', registry=registry)
            logger.info("Done")
        else:
            logger.error("Validation failed")
            exit(1)

---
# Prometheus ServiceMonitor to scrape Pushgateway metrics
apiVersion: monitoring.coreos.com/v1
kind: ServiceMonitor
metadata:
  name: cost-label-validation
  namespace: monitoring
  labels:
    app: cost-label-validation
    platform: platform-next

spec:
  selector:
    matchLabels:
      app: prometheus-pushgateway
  
  endpoints:
    - port: metrics
      interval: 5m
      scrapeTimeout: 10s
      relabelings:
        - sourceLabels: [__param_job]
          targetLabel: job
